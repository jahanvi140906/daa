<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>B-Tree Advanced Visualization | t=3</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #6366f1;
            --primary-dark: #4f46e5;
            --secondary: #8b5cf6;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --dark: #1e293b;
            --light: #f8fafc;
            --border: #e2e8f0;
            --shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1);
            --shadow-lg: 0 10px 15px -3px rgb(0 0 0 / 0.1);
        }

        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: var(--dark);
            overflow-x: hidden;
        }

        .glass-morphism {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border: 1px solid rgba(255, 255, 255, 0.2);
            box-shadow: var(--shadow-lg);
        }

        .header {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(20px);
            border-bottom: 1px solid rgba(255, 255, 255, 0.2);
            padding: 1rem 2rem;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .main-container {
            display: grid;
            grid-template-columns: 350px 1fr 300px;
            gap: 1.5rem;
            padding: 1.5rem;
            max-width: 1800px;
            margin: 0 auto;
            height: calc(100vh - 80px);
        }

        .panel {
            background: var(--light);
            border-radius: 16px;
            padding: 1.5rem;
            box-shadow: var(--shadow-lg);
            overflow-y: auto;
            border: 1px solid var(--border);
        }

        .panel-header {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--border);
        }

        .panel-title {
            font-size: 1.125rem;
            font-weight: 600;
            color: var(--dark);
        }

        .tree-container {
            background: var(--light);
            border-radius: 16px;
            padding: 2rem;
            box-shadow: var(--shadow-lg);
            position: relative;
            overflow: hidden; /* Changed to hidden to better manage internal scrolling/zooming */
            border: 1px solid var(--border);
            display: flex;
            flex-direction: column;
        }

        .tree-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 1.5rem;
            padding-bottom: 1rem;
            border-bottom: 2px solid var(--border);
        }

        .tree-content {
            flex: 1;
            position: relative;
            min-height: 600px;
            display: flex;
            justify-content: center;
            align-items: flex-start;
            padding: 2rem;
            overflow: auto; /* Make content scrollable */
        }
        
        /* Container for scaling and panning */
        #treeNodesContainer {
            position: relative;
            z-index: 2;
            width: fit-content;
            transition: transform 0.3s ease;
            transform-origin: top center;
        }

        .tree-svg {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            z-index: 1;
            /* SVG needs to cover the entire scrollable area */
            overflow: visible;
        }

        .tree-nodes {
            position: relative;
            z-index: 2;
            display: flex;
            justify-content: center;
            /* This is the root level container */
        }

        .tree-node {
            display: inline-flex;
            flex-direction: column;
            align-items: center;
            /* Adjusted margin for better horizontal spacing */
            margin: 0 20px; 
            position: relative;
        }

        .node-box {
            background: linear-gradient(135deg, var(--primary) 0%, var(--secondary) 100%);
            color: white;
            padding: 12px 16px;
            border-radius: 12px;
            min-width: 60px;
            text-align: center;
            font-weight: 600;
            font-size: 14px;
            box-shadow: 0 8px 25px rgba(99, 102, 241, 0.3);
            transition: all 0.3s ease;
            cursor: pointer;
            position: relative;
            border: 2px solid rgba(255, 255, 255, 0.2);
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
            white-space: nowrap; /* Prevent keys from wrapping */
        }

        .node-box.root {
            background: linear-gradient(135deg, var(--success) 0%, #059669 100%);
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.3);
        }

        .node-box.highlighted {
            background: linear-gradient(135deg, var(--warning) 0%, #d97706 100%);
            box-shadow: 0 12px 35px rgba(245, 158, 11, 0.5);
            transform: scale(1.05); /* Slightly less dramatic scale for search */
        }

        .node-box.splitting {
            animation: nodeSplit 1s ease-in-out;
        }

        @keyframes nodeSplit {
            0%, 100% { transform: scale(1); }
            50% { transform: scale(1.2); opacity: 0.7; }
        }

        .node-box.merging {
            animation: nodeMerge 1s ease-in-out;
        }

        @keyframes nodeMerge {
            0% { transform: scale(1); }
            50% { transform: scale(0.8); opacity: 0.7; }
            100% { transform: scale(1); }
        }

        .node-key {
            background: rgba(255, 255, 255, 0.2);
            padding: 4px 8px;
            border-radius: 6px;
            margin: 0 2px;
            transition: all 0.5s ease;
            font-family: monospace;
        }

        .node-key.new {
            animation: keyAppear 0.8s ease-out;
            background: rgba(16, 185, 129, 0.4);
        }

        .node-key.deleting {
            animation: keyDisappear 0.8s ease-out;
            background: rgba(239, 68, 68, 0.4);
        }

        .node-key.promoting {
            animation: keyPromote 1s ease-in-out;
            background: rgba(245, 158, 11, 0.6);
        }
        
        .node-key.demoting {
            background: rgba(239, 68, 68, 0.6);
        }
        
        .node-key.borrowed {
            background: rgba(99, 102, 241, 0.6);
        }

        @keyframes keyAppear {
            from { transform: scale(0); opacity: 0; }
            to { transform: scale(1); opacity: 1; }
        }

        @keyframes keyDisappear {
            from { transform: scale(1); opacity: 1; }
            to { transform: scale(0); opacity: 0; }
        }

        @keyframes keyPromote {
            0% { transform: translateY(0); }
            50% { transform: translateY(-30px); opacity: 0.5; }
            100% { transform: translateY(0); opacity: 1; }
        }

        .node-children {
            display: flex;
            justify-content: center;
            margin-top: 50px;
            /* Adjusted gap to be relative to node width */
            gap: 15px; 
            position: relative;
        }

        .tree-edge {
            stroke: var(--primary);
            stroke-width: 3;
            fill: none;
            stroke-linecap: round;
            z-index: 1;
            transition: all 0.3s ease;
        }

        .tree-edge.highlighted {
            stroke: var(--warning);
            stroke-width: 5;
            filter: drop-shadow(0 0 10px rgba(245, 158, 11, 0.6));
        }

        .form-group {
            margin-bottom: 1.5rem;
        }

        .form-label {
            display: block;
            font-size: 0.875rem;
            font-weight: 600;
            color: var(--dark);
            margin-bottom: 0.5rem;
        }

        .form-input {
            width: 100%;
            padding: 0.75rem 1rem;
            border: 2px solid var(--border);
            border-radius: 10px;
            font-size: 0.875rem;
            transition: all 0.3s ease;
            background: white;
        }

        .form-input:focus {
            outline: none;
            border-color: var(--primary);
            box-shadow: 0 0 0 3px rgba(99, 102, 241, 0.1);
        }

        .btn {
            padding: 0.75rem 1.5rem;
            border: none;
            border-radius: 10px;
            font-size: 0.875rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.5rem;
        }

        .btn-primary {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(99, 102, 241, 0.3);
        }

        .btn-primary:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(99, 102, 241, 0.4);
        }

        .btn-success {
            background: linear-gradient(135deg, var(--success) 0%, #059669 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(16, 185, 129, 0.3);
        }
        
        .btn-success:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(16, 185, 129, 0.4);
        }

        .btn-danger {
            background: linear-gradient(135deg, var(--danger) 0%, #dc2626 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(239, 68, 68, 0.3);
        }
        
        .btn-danger:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(239, 68, 68, 0.4);
        }

        .btn-warning {
            background: linear-gradient(135deg, var(--warning) 0%, #d97706 100%);
            color: white;
            box-shadow: 0 4px 15px rgba(245, 158, 11, 0.3);
        }
        
        .btn-warning:hover {
            transform: translateY(-2px);
            box-shadow: 0 8px 25px rgba(245, 158, 11, 0.4);
        }

        .btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
            transform: none !important;
        }

        .btn-group {
            display: grid;
            grid-template-columns: repeat(2, 1fr);
            gap: 0.75rem;
            margin-top: 1rem;
        }

        .animation-controls {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 1rem;
        }

        .speed-control {
            margin-top: 1rem;
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: var(--border);
            outline: none;
            -webkit-appearance: none;
            appearance: none;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: var(--primary);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(99, 102, 241, 0.3);
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 1rem 1.5rem;
            border-radius: 12px;
            color: white;
            font-size: 0.875rem;
            font-weight: 500;
            box-shadow: 0 10px 25px rgba(0, 0, 0, 0.2);
            z-index: 1000;
            transition: opacity 0.3s ease, transform 0.3s ease;
        }

        .notification.success {
            background: linear-gradient(135deg, var(--success) 0%, #059669 100%);
        }

        .notification.error {
            background: linear-gradient(135deg, var(--danger) 0%, #dc2626 100%);
        }

        .notification.info {
            background: linear-gradient(135deg, var(--primary) 0%, var(--primary-dark) 100%);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1rem;
            margin-top: 1.5rem;
        }

        .stat-card {
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            padding: 1rem;
            border-radius: 12px;
            text-align: center;
            border: 1px solid var(--border);
            transition: all 0.3s ease;
        }

        .stat-value {
            font-size: 1.875rem;
            font-weight: 700;
            color: var(--primary);
            margin-bottom: 0.25rem;
        }

        .stat-label {
            font-size: 0.75rem;
            color: #64748b;
            font-weight: 500;
        }

        .step-item {
            display: flex;
            align-items: flex-start;
            gap: 0.75rem;
            margin-bottom: 1rem;
            padding: 1rem;
            background: linear-gradient(135deg, #f8fafc 0%, #e2e8f0 100%);
            border-radius: 10px;
            border-left: 3px solid var(--primary);
            animation: stepSlideIn 0.3s ease-out;
        }
        
        .step-item.active {
            border-left: 3px solid var(--warning);
            background: linear-gradient(135deg, #fffbeb 0%, #fef3c7 100%);
        }

        @keyframes stepSlideIn {
            from { transform: translateX(-20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        .step-icon {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--primary);
            color: white;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.75rem;
            flex-shrink: 0;
        }
        
        .step-item.active .step-icon {
            background: var(--warning);
        }

        .step-content {
            flex: 1;
        }

        .step-title {
            font-weight: 600;
            font-size: 0.875rem;
            margin-bottom: 0.25rem;
        }

        .step-description {
            font-size: 0.75rem;
            color: #64748b;
        }

        .code-block {
            background: #1e293b;
            color: #e2e8f0;
            padding: 1rem;
            border-radius: 8px;
            font-family: 'Fira Code', 'Courier New', monospace;
            font-size: 0.75rem;
            line-height: 1.5;
            overflow-x: auto;
            margin-top: 1rem;
        }

        .code-keyword { color: #c084fc; }
        .code-function { color: #60a5fa; }
        .code-string { color: #86efac; }
        .code-comment { color: #64748b; }
        .code-variable { color: #f59e0b; }
        .code-number { color: #10b981; }

        .complexity-panel {
            background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%);
            border: 2px solid #fbbf24;
            border-radius: 12px;
            padding: 1rem;
            margin-top: 1rem;
        }

        .complexity-title {
            font-weight: 700;
            color: #92400e;
            margin-bottom: 0.75rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .complexity-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.8);
            border-radius: 8px;
            margin-bottom: 0.5rem;
            transition: all 0.3s ease;
        }

        .complexity-item:hover {
            background: rgba(255, 255, 255, 1);
            transform: translateX(4px);
        }

        .complexity-operation {
            font-weight: 600;
            color: #451a03;
            font-size: 0.875rem;
        }

        .complexity-value {
            background: linear-gradient(135deg, #f59e0b 0%, #d97706 100%);
            color: white;
            padding: 0.25rem 0.75rem;
            border-radius: 20px;
            font-weight: 700;
            font-size: 0.75rem;
            font-family: 'Courier New', monospace;
        }

        .complexity-best {
            background: linear-gradient(135deg, #10b981 0%, #059669 100%);
        }

        .complexity-worst {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
        }

        .complexity-average {
            background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
        }

        .big-o {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            font-size: 1.1em;
        }

        .complexity-formula {
            background: #1e293b;
            color: #e2e8f0;
            padding: 0.75rem;
            border-radius: 8px;
            font-family: 'Courier New', monospace;
            font-size: 0.75rem;
            margin-top: 0.75rem;
            border-left: 3px solid #fbbf24;
        }

        .complexity-explanation {
            font-size: 0.75rem;
            color: #78350f;
            margin-top: 0.5rem;
            line-height: 1.4;
        }

        @media (max-width: 1400px) {
            .main-container {
                grid-template-columns: 300px 1fr 280px;
                gap: 1rem;
                padding: 1rem;
            }
        }

        @media (max-width: 768px) {
            .main-container {
                grid-template-columns: 1fr;
                height: auto;
            }
            .panel {
                margin-bottom: 1rem;
            }
        }
    </style>
</head>
<body>
    <header class="header">
        <div class="flex items-center justify-between">
            <div class="flex items-center gap-3">
                <div class="w-10 h-10 bg-white rounded-lg flex items-center justify-center">
                    <i class="fas fa-sitemap text-indigo-600"></i>
                </div>
                <div>
                    <h1 class="text-2xl font-bold text-white">B-Tree Advanced Visualization</h1>
                    <p class="text-white/80 text-sm">Interactive Operations with t=3 (Min Degree)</p>
                </div>
            </div>
            <div class="flex items-center gap-3">
                <button onclick="toggleTheme()" class="btn btn-primary">
                    <i class="fas fa-moon"></i>
                    Theme
                </button>
            </div>
        </div>
    </header>

    <main class="main-container">
        <aside class="panel">
            <div class="panel-header">
                <i class="fas fa-play-circle text-indigo-600"></i>
                <h2 class="panel-title">Animation Controls</h2>
            </div>

            <div class="animation-controls">
                <button id="playBtn" onclick="playAnimation()" class="btn btn-success" disabled>
                    <i class="fas fa-play"></i>
                </button>
                <button id="pauseBtn" onclick="pauseAnimation()" class="btn btn-warning" disabled>
                    <i class="fas fa-pause"></i>
                </button>
                <button id="stepBtn" onclick="stepForward()" class="btn btn-primary" disabled>
                    <i class="fas fa-step-forward"></i>
                </button>
                <button id="resetBtn" onclick="clearTree()" class="btn btn-danger">
                    <i class="fas fa-redo"></i>
                    Clear
                </button>
            </div>

            <div class="speed-control">
                <label class="form-label">Animation Speed</label>
                <input type="range" id="speedSlider" min="0.5" max="3" step="0.5" value="1.5" class="slider" oninput="updateSpeedDisplay(this.value)">
                <div class="flex justify-between text-xs text-gray-500">
                    <span>Slow</span>
                    <span id="speedValue">1.5s</span>
                    <span>Fast</span>
                </div>
            </div>

            <div class="panel-header">
                <i class="fas fa-cog text-indigo-600"></i>
                <h2 class="panel-title">B-Tree Configuration</h2>
            </div>

            <div class="form-group">
                <label class="form-label">B-Tree Order (Degree t)</label>
                <select id="orderSelect" onchange="changeTreeOrder()" class="form-input">
                    <option value="2">t=2 (Order 4) - Max 3 keys</option>
                    <option value="3" selected>t=3 (Order 6) - Max 5 keys</option>
                    <option value="4">t=4 (Order 8) - Max 7 keys</option>
                    <option value="5">t=5 (Order 10) - Max 9 keys</option>
                </select>
                <div class="text-xs text-gray-500 mt-1">
                    <span id="orderInfo">Current: t=3, Min keys=2, Max keys=5</span>
                </div>
            </div>

            <div class="panel-header">
                <i class="fas fa-plus-circle text-green-600"></i>
                <h2 class="panel-title">Manual Operations</h2>
            </div>

            <div class="form-group">
                <label class="form-label">Insert Key (Numeric/String)</label>
                <div class="flex gap-2">
                    <input type="text" id="keyInput" placeholder="e.g., 42, A, apple" class="form-input" onkeydown="handleKeyInput(event, insertKey)">
                    <button onclick="insertKey()" class="btn btn-primary">
                        <i class="fas fa-plus"></i>
                        Insert
                    </button>
                </div>
            </div>

            <div class="form-group">
                <label class="form-label">Delete Key (Must exist)</label>
                <div class="flex gap-2">
                    <input type="text" id="deleteInput" placeholder="e.g., 42, A, apple" class="form-input" onkeydown="handleKeyInput(event, deleteKey)">
                    <button onclick="deleteKey()" class="btn btn-danger">
                        <i class="fas fa-minus"></i>
                        Delete
                    </button>
                </div>
            </div>

            <div class="btn-group">
                <button onclick="generateInsertSequence()" class="btn btn-success">
                    <i class="fas fa-layer-group"></i>
                    Auto Insert
                </button>
                <button onclick="generateDeleteSequence()" class="btn btn-danger">
                    <i class="fas fa-trash-alt"></i>
                    Auto Delete
                </button>
                <button onclick="generateRandomTree()" class="btn btn-primary">
                    <i class="fas fa-dice"></i>
                    Random Fill
                </button>
                <button onclick="clearTree()" class="btn btn-warning">
                    <i class="fas fa-broom"></i>
                    Reset
                </button>
            </div>
        </aside>

        <section class="tree-container">
            <div class="tree-header">
                <div class="flex items-center gap-3">
                    <i class="fas fa-project-diagram text-indigo-600"></i>
                    <h2 class="panel-title">B-Tree Visualization (t=<span id="currentDegree">3</span>)</h2>
                    <span class="text-sm text-gray-600">Max Keys: <span id="maxKeysDisplay">5</span>, Min Keys: <span id="minKeysDisplay">2</span></span>
                </div>
                <div class="flex items-center gap-3">
                    <button onclick="zoomIn()" class="btn btn-primary">
                        <i class="fas fa-search-plus"></i>
                    </button>
                    <button onclick="zoomOut()" class="btn btn-primary">
                        <i class="fas fa-search-minus"></i>
                    </button>
                    <button onclick="resetZoom()" class="btn btn-primary">
                        <i class="fas fa-compress"></i>
                    </button>
                </div>
            </div>
            <div id="treeContent" class="tree-content">
                <svg id="treeSvg" class="tree-svg"></svg>
                <div id="treeNodesContainer">
                    <div id="treeNodes" class="tree-nodes">
                        <div class="text-center text-gray-500 mt-20">
                            <i class="fas fa-sitemap text-6xl mb-4 opacity-50"></i>
                            <p class="text-xl font-semibold">Empty B-Tree</p>
                            <p class="text-sm mt-2">Click "Auto Insert" or manually insert keys to begin</p>
                        </div>
                    </div>
                </div>
            </div>
        </section>

        <aside class="panel">
            <div class="panel-header">
                <i class="fas fa-info-circle text-blue-600"></i>
                <h2 class="panel-title">Tree Statistics</h2>
            </div>

            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-value" id="totalKeys">0</div>
                    <div class="stat-label">Total Keys</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="treeHeight">0</div>
                    <div class="stat-label">Tree Height</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="nodeCount">0</div>
                    <div class="stat-label">Node Count</div>
                </div>
                <div class="stat-card">
                    <div class="stat-value" id="lastOp">None</div>
                    <div class="stat-label">Last Operation</div>
                </div>
            </div>

            <div class="panel-header">
                <i class="fas fa-code text-indigo-600"></i>
                <h2 class="panel-title">Current Operation</h2>
            </div>

            <div id="pseudocode" class="code-block">
                <div><span class="code-comment">// Ready for operations</span></div>
                <div><span class="code-keyword">function</span> <span class="code-function">START</span>():</div>
                <div>&nbsp; Insert or delete keys</div>
                <div>&nbsp; Watch animations</div>
                <div>&nbsp; Observe B-tree properties</div>
            </div>

            <div class="panel-header">
                <i class="fas fa-list-ol text-purple-600"></i>
                <h2 class="panel-title">Operation Steps</h2>
            </div>

            <div id="operationSteps">
                <div class="step-item">
                    <div class="step-icon">
                        <i class="fas fa-info" style="font-size: 10px;"></i>
                    </div>
                    <div class="step-content">
                        <div class="step-title">Ready</div>
                        <div class="step-description">Start inserting or deleting keys to see detailed steps...</div>
                    </div>
                </div>
            </div>

            <div class="complexity-panel" id="complexityPanel">
                <div class="complexity-title">
                    <i class="fas fa-chart-line text-amber-600"></i>
                    Time Complexity Analysis
                </div>
                
                <div class="complexity-item">
                    <span class="complexity-operation">Search</span>
                    <span class="complexity-value complexity-best"><span class="big-o">O</span>(logₜ n)</span>
                </div>
                
                <div class="complexity-item">
                    <span class="complexity-operation">Insert</span>
                    <span class="complexity-value complexity-average"><span class="big-o">O</span>(logₜ n)</span>
                </div>
                
                <div class="complexity-item">
                    <span class="complexity-operation">Delete</span>
                    <span class="complexity-value complexity-worst"><span class="big-o">O</span>(logₜ n)</span>
                </div>
                
                <div class="complexity-formula">
                    <div><span class="code-comment">// Where t = minimum degree (3)</span></div>
                    <div><span class="code-comment">// n = number of keys in tree</span></div>
                    <div><span class="code-comment">// Height h &le; logₜ((n+1)/2)</span></div>
                </div>
                
                <div class="complexity-explanation">
                    <strong>Why O(logₜ n)?</strong> B-trees maintain balance by ensuring all leaf nodes are at the same depth. With minimum degree t=3, each internal node (except root) has between t-1 and 2t-1 keys, guaranteeing logarithmic height.
                </div>
            </div>
        </aside>
    </main>

    <script>
        // --- Configuration ---
        let MIN_DEGREE = 3;
        let MAX_KEYS = 2 * MIN_DEGREE - 1; // 5
        let MIN_KEYS = MIN_DEGREE - 1; // 2

        // --- Global State ---
        let bTree = null;
        let animationQueue = [];
        let isAnimating = false;
        let animationSpeed = 1500; // Default speed in ms
        let currentZoom = 1.0;
        const KEY_COUNT_LIMIT = 50; // Max keys for auto-generation

        // --- Utility Functions ---

        function showNotification(message, type = 'info', duration = 3000) {
            const container = document.body;
            const notification = document.createElement('div');
            notification.classList.add('notification', type);
            notification.innerHTML = `<i class="fas fa-bell mr-2"></i>${message}`;
            
            // Initial state for animation
            notification.style.opacity = '0';
            notification.style.transform = 'translateY(-20px)';
            container.appendChild(notification);

            // Animate in
            setTimeout(() => {
                notification.style.opacity = '1';
                notification.style.transform = 'translateY(0)';
            }, 10);

            // Animate out and remove
            setTimeout(() => {
                notification.style.opacity = '0';
                notification.style.transform = 'translateY(-20px)';
                setTimeout(() => {
                    container.removeChild(notification);
                }, 300);
            }, duration);
        }
        
        function updateSpeedDisplay(value) {
            const speedValue = parseFloat(value);
            animationSpeed = speedValue * 1000;
            document.getElementById('speedValue').textContent = `${speedValue.toFixed(1)}s`;
        }

        function handleKeyInput(event, operationFunction) {
            if (event.key === 'Enter') {
                operationFunction();
            }
        }

        // --- B-Tree Node Class ---

        class BTreeNode {
            constructor(isLeaf = true) {
                this.keys = [];
                this.children = [];
                this.isLeaf = isLeaf;
                this.id = Math.random().toString(36).substr(2, 9);
                this.x = 0; // for visualization position
                this.y = 0; // for visualization position
            }

            isFull() {
                return this.keys.length >= MAX_KEYS;
            }

            hasMinKeys() {
                return this.keys.length >= MIN_KEYS;
            }

            findKeyIndex(key) {
                let idx = 0;
                while (idx < this.keys.length && this.compareKeys(this.keys[idx], key) < 0) {
                    idx++;
                }
                return idx;
            }

            compareKeys(key1, key2) {
                // Ensure comparison is consistent
                const k1 = isNaN(Number(key1)) ? String(key1) : Number(key1);
                const k2 = isNaN(Number(key2)) ? String(key2) : Number(key2);

                if (typeof k1 === 'number' && typeof k2 === 'number') {
                    return k1 - k2;
                }
                return String(k1).localeCompare(String(k2));
            }
        }

        // --- B-Tree Class (Core Logic) ---

        class BTree {
            constructor() {
                this.root = null;
                this.totalKeys = 0;
                this.nodes = {}; // Track all nodes by ID
            }
            
            init(degree) {
                MIN_DEGREE = parseInt(degree);
                MAX_KEYS = 2 * MIN_DEGREE - 1;
                MIN_KEYS = MIN_DEGREE - 1;
                this.clear();
                updateDisplayInfo();
            }
            
            clear() {
                this.root = null;
                this.totalKeys = 0;
                this.nodes = {};
            }

            insert(key) {
                key = this.normalizeKey(key);
                if (key === null) return [];

                if (this.search(key).found) {
                    showNotification(`Key ${key} already exists.`, 'error');
                    return [];
                }

                const steps = [];

                if (this.root === null) {
                    this.root = new BTreeNode(true);
                    this.root.keys.push(key);
                    this.nodes[this.root.id] = this.root;
                    this.totalKeys++;
                    steps.push({ type: 'new_root', key, node: this.root });
                    return steps;
                }

                // If root is full, split it first
                if (this.root.isFull()) {
                    const oldRoot = this.root;
                    const newRoot = new BTreeNode(false);
                    this.nodes[newRoot.id] = newRoot;
                    newRoot.children.push(oldRoot);
                    this.root = newRoot;
                    steps.push({ type: 'split_root_start', oldRoot, newRoot });
                    
                    this.splitChild(newRoot, 0, steps);

                    steps.push({ type: 'split_root_end', newRoot });
                }
                
                this.insertNonFull(this.root, key, steps);
                this.totalKeys++;
                return steps;
            }

            insertNonFull(node, key, steps) {
                let idx = node.findKeyIndex(key);
                steps.push({ type: 'traverse_insert', key, node, childIndex: idx });

                if (node.isLeaf) {
                    // Insert key into leaf node
                    node.keys.splice(idx, 0, key);
                    steps.push({ type: 'inserted_leaf', key, node, index: idx });
                } else {
                    // Descend to child
                    let child = node.children[idx];
                    
                    // If child is full, split it
                    if (child.isFull()) {
                        steps.push({ type: 'split_child_start', parent: node, child, childIndex: idx });
                        this.splitChild(node, idx, steps);
                        steps.push({ type: 'split_child_end', parent: node });
                        
                        // After split, determine which of the two new children to insert into
                        if (node.compareKeys(node.keys[idx], key) < 0) {
                            idx++;
                            child = node.children[idx];
                            steps.push({ type: 're_traverse', key, node, childIndex: idx });
                        }
                    }
                    
                    this.insertNonFull(child, key, steps);
                }
            }

            splitChild(parent, index, steps) {
                const fullChild = parent.children[index];
                const newNode = new BTreeNode(fullChild.isLeaf);
                this.nodes[newNode.id] = newNode;
                
                const midIndex = MIN_DEGREE - 1; // Index of the key to be promoted
                const promotedKey = fullChild.keys[midIndex];
                
                // New node takes keys > promotedKey
                newNode.keys = fullChild.keys.slice(midIndex + 1);
                fullChild.keys = fullChild.keys.slice(0, midIndex);
                
                // If not leaf, new node takes children (MIN_DEGREE to 2*MIN_DEGREE - 1)
                if (!fullChild.isLeaf) {
                    const childrenToMove = fullChild.children.splice(MIN_DEGREE);
                    newNode.children = childrenToMove;
                }
                
                // Insert new node and promoted key into parent
                parent.children.splice(index + 1, 0, newNode);
                parent.keys.splice(index, 0, promotedKey);

                steps.push({ 
                    type: 'split_complete', 
                    parent, 
                    promotedKey, 
                    fullChild, 
                    newNode, 
                    index 
                });
            }

            // --- Deletion Logic ---

            delete(key) {
                key = this.normalizeKey(key);
                if (key === null) return [];

                const searchResult = this.search(key);
                if (!searchResult.found) {
                    showNotification(`Key ${key} not found for deletion.`, 'error');
                    return [];
                }

                const steps = [];
                this.deleteKeyFromNode(this.root, key, steps);
                
                // Post-deletion: If root has 0 keys and children, it collapses
                if (this.root.keys.length === 0) {
                    if (this.root.isLeaf) {
                        this.root = null;
                        steps.push({ type: 'tree_cleared' });
                    } else {
                        const oldRoot = this.root;
                        this.root = this.root.children[0];
                        steps.push({ type: 'root_collapsed', oldRoot, newRoot: this.root });
                    }
                }
                
                this.totalKeys--;
                return steps;
            }

            deleteKeyFromNode(node, key, steps) {
                let idx = node.findKeyIndex(key);

                // Case 1: Key is in the current internal node
                if (idx < node.keys.length && node.compareKeys(node.keys[idx], key) === 0) {
                    steps.push({ type: 'found_for_delete', key, node, index: idx });

                    if (node.isLeaf) {
                        // Case 1a: Key is in a leaf node
                        node.keys.splice(idx, 1);
                        steps.push({ type: 'deleted_leaf', key, node });
                        return;
                    } else {
                        // Case 1b: Key is in an internal node
                        const leftChild = node.children[idx];
                        const rightChild = node.children[idx + 1];

                        if (leftChild.keys.length >= MIN_DEGREE) {
                            // Find predecessor in left child's subtree
                            let predecessor = this.getPredecessor(leftChild, steps);
                            steps.push({ 
                                type: 'predecessor_swap', 
                                key, 
                                node, 
                                index: idx, 
                                predecessor 
                            });
                            node.keys[idx] = predecessor;
                            this.deleteKeyFromNode(leftChild, predecessor, steps);
                        } else if (rightChild.keys.length >= MIN_DEGREE) {
                            // Find successor in right child's subtree
                            let successor = this.getSuccessor(rightChild, steps);
                            steps.push({ 
                                type: 'successor_swap', 
                                key, 
                                node, 
                                index: idx, 
                                successor 
                            });
                            node.keys[idx] = successor;
                            this.deleteKeyFromNode(rightChild, successor, steps);
                        } else {
                            // Merge left and right children
                            steps.push({ type: 'merge_children_start', parent: node, key, index: idx, leftChild, rightChild });
                            this.mergeChildren(node, idx, steps);
                            // After merge, key is in the merged node (leftChild now)
                            this.deleteKeyFromNode(leftChild, key, steps);
                        }
                    }
                } 
                // Case 2: Key is not in current node (descend)
                else {
                    if (node.isLeaf) {
                        return; // Key not found (shouldn't happen if search worked)
                    }

                    steps.push({ type: 'traverse_delete', key, node, childIndex: idx });
                    let child = node.children[idx];

                    if (child.keys.length === MIN_KEYS - 1) { // Child is deficient
                        steps.push({ type: 'deficient_child', node, child, childIndex: idx });
                        this.handleDeficientChild(node, idx, steps);
                        
                        // After handling deficiency, check which child to continue with
                        if (idx < node.keys.length && node.compareKeys(key, node.keys[idx]) > 0) {
                            idx++; // Descend right if key is greater than the new key added to the parent
                        }
                    }

                    this.deleteKeyFromNode(node.children[idx], key, steps);
                }
            }

            // Helper for Case 1b: Finds the largest key in the left subtree (max key in a leaf)
            getPredecessor(node, steps) {
                steps.push({ type: 'find_predecessor', node });
                while (!node.isLeaf) {
                    node = node.children[node.children.length - 1];
                    steps.push({ type: 'traverse_predecessor', node });
                }
                return node.keys[node.keys.length - 1];
            }

            // Helper for Case 1b: Finds the smallest key in the right subtree (min key in a leaf)
            getSuccessor(node, steps) {
                steps.push({ type: 'find_successor', node });
                while (!node.isLeaf) {
                    node = node.children[0];
                    steps.push({ type: 'traverse_successor', node });
                }
                return node.keys[0];
            }

            // Helper for Case 2: Handles deficient child (t-1 keys)
            handleDeficientChild(parent, idx, steps) {
                const child = parent.children[idx];
                const leftSibling = idx > 0 ? parent.children[idx - 1] : null;
                const rightSibling = idx < parent.children.length - 1 ? parent.children[idx + 1] : null;

                // Case 2a: Try to borrow from left sibling
                if (leftSibling && leftSibling.keys.length >= MIN_DEGREE) {
                    steps.push({ type: 'borrow_left_start', parent, child, leftSibling });
                    
                    // Parent key moves down, sibling key moves up
                    const parentKey = parent.keys[idx - 1];
                    const borrowedKey = leftSibling.keys.pop();
                    
                    child.keys.unshift(parentKey);
                    parent.keys[idx - 1] = borrowedKey;
                    
                    if (!child.isLeaf) {
                        // Move last child pointer from leftSibling to child
                        const childToMove = leftSibling.children.pop();
                        child.children.unshift(childToMove);
                    }
                    
                    steps.push({ type: 'borrow_left_end', parent, child, leftSibling, parentKey, borrowedKey });
                } 
                // Case 2b: Try to borrow from right sibling
                else if (rightSibling && rightSibling.keys.length >= MIN_DEGREE) {
                    steps.push({ type: 'borrow_right_start', parent, child, rightSibling });
                    
                    // Parent key moves down, sibling key moves up
                    const parentKey = parent.keys[idx];
                    const borrowedKey = rightSibling.keys.shift();
                    
                    child.keys.push(parentKey);
                    parent.keys[idx] = borrowedKey;
                    
                    if (!child.isLeaf) {
                        // Move first child pointer from rightSibling to child
                        const childToMove = rightSibling.children.shift();
                        child.children.push(childToMove);
                    }

                    steps.push({ type: 'borrow_right_end', parent, child, rightSibling, parentKey, borrowedKey });
                } 
                // Case 2c: Merge with a sibling
                else {
                    if (leftSibling) {
                        // Merge with left sibling
                        steps.push({ type: 'merge_left_start', parent, child, leftSibling, index: idx - 1 });
                        this.mergeChildren(parent, idx - 1, steps); // Merge leftSibling and child
                    } else if (rightSibling) {
                        // Merge with right sibling
                        steps.push({ type: 'merge_right_start', parent, child, rightSibling, index: idx });
                        this.mergeChildren(parent, idx, steps); // Merge child and rightSibling
                    }
                }
            }

            // Helper for Case 1b and 2c: Merges child[idx] and child[idx+1]
            mergeChildren(parent, idx, steps) {
                const left = parent.children[idx];
                const right = parent.children[idx + 1];
                const medianKey = parent.keys[idx];

                // Pull down parent key
                left.keys.push(medianKey);
                
                // Merge keys from right to left
                left.keys = left.keys.concat(right.keys);
                
                // Merge children if not leaf
                if (!left.isLeaf) {
                    left.children = left.children.concat(right.children);
                }
                
                // Remove median key and right child from parent
                parent.keys.splice(idx, 1);
                parent.children.splice(idx + 1, 1);
                
                // Clean up merged node reference
                delete this.nodes[right.id];
                
                steps.push({ type: 'merged_complete', parent, left, right, medianKey, index: idx });
            }

            search(key) {
                key = this.normalizeKey(key);
                if (this.root === null) return { found: false, steps: [] };
                
                const steps = [];
                let node = this.root;
                let found = false;

                while (node) {
                    let idx = node.findKeyIndex(key);
                    
                    if (idx < node.keys.length && node.compareKeys(node.keys[idx], key) === 0) {
                        steps.push({ type: 'search_hit', key, node, index: idx });
                        found = true;
                        break;
                    } else if (node.isLeaf) {
                        steps.push({ type: 'search_miss_leaf', key, node });
                        break;
                    } else {
                        steps.push({ type: 'search_traverse', key, node, childIndex: idx });
                        node = node.children[idx];
                    }
                }

                return { found, steps };
            }

            normalizeKey(key) {
                key = String(key).trim();
                if (key === "") return null;
                
                if (!isNaN(Number(key)) && key.length > 0) {
                    return Number(key);
                }
                return key.toUpperCase(); // Standardize strings
            }

            // --- Visualization Helpers (for stats) ---

            getHeight(node = this.root) {
                if (node === null) return 0;
                let h = 1;
                let current = node;
                while (!current.isLeaf) {
                    current = current.children[0];
                    h++;
                }
                return h;
            }

            getNodeCount(node = this.root) {
                if (node === null) return 0;
                let count = 1;
                for (const child of node.children) {
                    count += this.getNodeCount(child);
                }
                return count;
            }
        }

        // --- Visualization Rendering ---

        function updateDisplayInfo() {
            document.getElementById('currentDegree').textContent = MIN_DEGREE;
            document.getElementById('maxKeysDisplay').textContent = MAX_KEYS;
            document.getElementById('minKeysDisplay').textContent = MIN_KEYS;
            document.getElementById('orderInfo').textContent = `Current: t=${MIN_DEGREE}, Min keys=${MIN_KEYS}, Max keys=${MAX_KEYS}`;

            if (bTree) {
                document.getElementById('totalKeys').textContent = bTree.totalKeys;
                document.getElementById('treeHeight').textContent = bTree.getHeight();
                document.getElementById('nodeCount').textContent = bTree.getNodeCount();
            } else {
                document.getElementById('totalKeys').textContent = 0;
                document.getElementById('treeHeight').textContent = 0;
                document.getElementById('nodeCount').textContent = 0;
            }
        }

        function renderTree(root, containerId = 'treeNodes', svgId = 'treeSvg') {
            const container = document.getElementById(containerId);
            const svg = document.getElementById(svgId);

            // Clear previous content
            container.innerHTML = '';
            svg.innerHTML = '';
            
            if (!root) {
                container.innerHTML = `<div class="text-center text-gray-500 mt-20">
                    <i class="fas fa-sitemap text-6xl mb-4 opacity-50"></i>
                    <p class="text-xl font-semibold">Empty B-Tree</p>
                    <p class="text-sm mt-2">Click "Auto Insert" or manually insert keys to begin</p>
                </div>`;
                updateDisplayInfo();
                return;
            }
            
            // 1. Recursive Render to calculate initial positions and build HTML structure
            const rootEl = renderNode(root);
            container.appendChild(rootEl);
            
            // 2. Position Nodes and Draw Edges
            
            // Use a post-render layout system for accurate positioning (Tree layout algorithm)
            // This is a simplified, non-d3-based horizontal layout
            const nodeElements = Array.from(container.querySelectorAll('.tree-node'));
            
            // Constants for layout
            const NODE_HEIGHT = 70;
            const VERTICAL_SPACING = 50;
            const PADDING_X = 20;

            let maxDepth = 0;

            // Step 2a: Calculate width and depth (x, y) for each node
            const layout = {};
            let currentX = PADDING_X;

            function calculateLayout(nodeEl, node, depth) {
                if (!nodeEl) return 0;

                maxDepth = Math.max(maxDepth, depth);

                const nodeWidth = nodeEl.offsetWidth;
                let totalWidth = 0;

                if (!node.isLeaf) {
                    // Recurse on children first
                    const childrenEls = Array.from(nodeEl.querySelector('.node-children').children);
                    
                    for (let i = 0; i < node.children.length; i++) {
                        totalWidth += calculateLayout(childrenEls[i], node.children[i], depth + 1);
                    }
                    
                    // The node's center is the center of its children's span
                    const leftChildCenter = layout[node.children[0].id].center;
                    const rightChildCenter = layout[node.children[node.children.length - 1].id].center;
                    const center = (leftChildCenter + rightChildCenter) / 2;
                    
                    layout[node.id] = {
                        width: nodeWidth,
                        x: center - nodeWidth / 2,
                        y: depth * (NODE_HEIGHT + VERTICAL_SPACING),
                        center: center,
                        depth: depth,
                        element: nodeEl
                    };
                    
                    return totalWidth; // Return total width of children subtree
                    
                } else {
                    // Leaf Node: Calculate its position sequentially
                    const center = currentX + nodeWidth / 2;
                    
                    layout[node.id] = {
                        width: nodeWidth,
                        x: currentX,
                        y: depth * (NODE_HEIGHT + VERTICAL_SPACING),
                        center: center,
                        depth: depth,
                        element: nodeEl
                    };
                    
                    currentX += nodeWidth + PADDING_X * 2;
                    return nodeWidth + PADDING_X * 2;
                }
            }
            
            const rootEl_ = container.querySelector('.tree-node');
            if (rootEl_) {
                calculateLayout(rootEl_, root, 0);
            }
            
            // Adjust Root X position to center the tree initially based on max width
            let finalWidth = 0;
            if (nodeElements.length > 0) {
                 // The final calculated width will be determined by the last leaf node placement (if calculated sequentially)
                finalWidth = currentX; 
            }
            
            // The tree container must be large enough to contain all nodes
            container.style.width = `${finalWidth + PADDING_X}px`; 
            
            // Center the root node in the computed width (only if the tree is not centered yet)
            const offsetX = (container.offsetWidth - layout[root.id].width) / 2 - layout[root.id].x;
            
            // Reposition all nodes using the calculated layout
            function applyLayoutAndDrawEdges(node) {
                const data = layout[node.id];
                if (!data) return; // Should not happen

                // Apply Node Position
                data.element.style.position = 'absolute';
                
                // If the tree width is less than the container width, calculate a new root offset to center the view
                const containerWidth = document.getElementById('treeContent').offsetWidth;
                let finalOffsetX = 0;
                if (containerWidth > data.element.parentElement.offsetWidth) {
                    finalOffsetX = (containerWidth - data.element.parentElement.offsetWidth) / 2;
                } else {
                    finalOffsetX = 0;
                }
                
                data.element.style.transform = `translate(${data.x + finalOffsetX}px, ${data.y}px)`;
                
                // Draw Edges to Children
                if (!node.isLeaf) {
                    const parentX = data.center + finalOffsetX;
                    const parentY = data.y + NODE_HEIGHT;
                    
                    node.children.forEach((child, i) => {
                        const childData = layout[child.id];
                        if (childData) {
                            const childX = childData.center + finalOffsetX;
                            const childY = childData.y;
                            
                            // Draw a smooth curved line (Bezier curve)
                            const midY = parentY + VERTICAL_SPACING / 2;
                            const path = `M ${parentX} ${parentY} C ${parentX} ${midY}, ${childX} ${midY}, ${childX} ${childY}`;
                            
                            const edge = document.createElementNS('http://www.w3.org/2000/svg', 'path');
                            edge.setAttribute('d', path);
                            edge.setAttribute('class', 'tree-edge');
                            edge.setAttribute('id', `edge-${node.id}-${child.id}`);
                            svg.appendChild(edge);
                            
                            applyLayoutAndDrawEdges(child); // Recursive call for children
                        }
                    });
                }
            }

            applyLayoutAndDrawEdges(root);
            
            // Set SVG size to cover the entire tree structure
            const totalTreeHeight = maxDepth * (NODE_HEIGHT + VERTICAL_SPACING) + NODE_HEIGHT + PADDING_X;
            svg.style.height = `${totalTreeHeight}px`;
            
            // Adjust the SVG and Nodes Container width to match the calculated width
            const nodesContainer = document.getElementById('treeNodesContainer');
            nodesContainer.style.width = `${finalWidth + 2 * PADDING_X}px`;
            svg.style.width = `${finalWidth + 2 * PADDING_X}px`;
            
            // Reset scroll/zoom
            document.getElementById('treeContent').scrollLeft = 0;
            document.getElementById('treeContent').scrollTop = 0;

            updateDisplayInfo();
        }

        function renderNode(node) {
            const nodeDiv = document.createElement('div');
            nodeDiv.classList.add('tree-node');
            nodeDiv.setAttribute('data-id', node.id);

            const box = document.createElement('div');
            box.classList.add('node-box');
            if (node === bTree.root) {
                box.classList.add('root');
            }

            node.keys.forEach(key => {
                const keySpan = document.createElement('span');
                keySpan.classList.add('node-key');
                keySpan.textContent = key;
                keySpan.setAttribute('data-key', key);
                box.appendChild(keySpan);
            });

            nodeDiv.appendChild(box);

            if (!node.isLeaf) {
                const childrenDiv = document.createElement('div');
                childrenDiv.classList.add('node-children');
                
                node.children.forEach(child => {
                    childrenDiv.appendChild(renderNode(child));
                });
                
                nodeDiv.appendChild(childrenDiv);
            }

            return nodeDiv;
        }

        function highlightNode(nodeId, className = 'highlighted', duration = 1000) {
            const nodeEl = document.querySelector(`.tree-node[data-id="${nodeId}"] .node-box`);
            if (nodeEl) {
                nodeEl.classList.add(className);
                setTimeout(() => {
                    nodeEl.classList.remove(className);
                }, duration);
            }
        }
        
        function highlightKey(nodeId, key, className = 'new', duration = 1000) {
            const nodeEl = document.querySelector(`.tree-node[data-id="${nodeId}"]`);
            if (nodeEl) {
                const keyEl = nodeEl.querySelector(`.node-key[data-key="${key}"]`);
                if (keyEl) {
                    keyEl.classList.add(className);
                    setTimeout(() => {
                        keyEl.classList.remove(className);
                    }, duration);
                }
            }
        }
        
        function highlightEdge(parentId, childId, className = 'highlighted', duration = 1000) {
            const edgeEl = document.getElementById(`edge-${parentId}-${childId}`);
            if (edgeEl) {
                edgeEl.classList.add(className);
                setTimeout(() => {
                    edgeEl.classList.remove(className);
                }, duration);
            }
        }
        
        function updatePseudocode(codeLines) {
            const pseudocodeEl = document.getElementById('pseudocode');
            pseudocodeEl.innerHTML = codeLines.map(line => {
                // Simple colorizer (expandable if needed)
                if (line.includes('//')) return `<div><span class="code-comment">${line}</span></div>`;
                if (line.includes('function')) return `<div><span class="code-keyword">function</span> <span class="code-function">${line.replace('function ', '')}</span></div>`;
                if (line.includes('if')) return `<div><span class="code-keyword">${line}</span></div>`;
                if (line.includes('else')) return `<div><span class="code-keyword">${line}</span></div>`;
                if (line.includes('RETURN')) return `<div><span class="code-keyword">${line}</span></div>`;
                if (line.includes('CALL')) return `<div><span class="code-function">${line}</span></div>`;
                return `<div>${line.replace(/([0-9]+)/g, '<span class="code-number">$1</span>').replace(/KEY|NODE|CHILD/g, '<span class="code-variable">$&</span>')}</div>`;
            }).join('');
        }
        
        function addStep(title, description, isActive = true) {
            const stepsContainer = document.getElementById('operationSteps');
            
            // Remove active class from previous steps
            Array.from(stepsContainer.children).forEach(step => step.classList.remove('active'));

            const stepDiv = document.createElement('div');
            stepDiv.classList.add('step-item');
            if (isActive) stepDiv.classList.add('active');
            
            const stepIcon = document.createElement('div');
            stepIcon.classList.add('step-icon');
            stepIcon.innerHTML = `<i class="fas fa-arrow-right" style="font-size: 10px;"></i>`;
            
            const stepContent = document.createElement('div');
            stepContent.classList.add('step-content');
            
            const stepTitle = document.createElement('div');
            stepTitle.classList.add('step-title');
            stepTitle.textContent = title;
            
            const stepDescription = document.createElement('div');
            stepDescription.classList.add('step-description');
            stepDescription.textContent = description;
            
            stepContent.appendChild(stepTitle);
            stepContent.appendChild(stepDescription);
            stepDiv.appendChild(stepIcon);
            stepDiv.appendChild(stepContent);
            
            stepsContainer.appendChild(stepDiv);
            stepsContainer.scrollTop = stepsContainer.scrollHeight; // Auto-scroll to latest step
        }
        
        function clearSteps() {
            document.getElementById('operationSteps').innerHTML = `<div class="step-item">
                <div class="step-icon">
                    <i class="fas fa-info" style="font-size: 10px;"></i>
                </div>
                <div class="step-content">
                    <div class="step-title">Ready</div>
                    <div class="step-description">Start inserting or deleting keys to see detailed steps...</div>
                </div>
            </div>`;
        }


        // --- Animation Management (FSM) ---

        function setAnimationControls(isPlaying) {
            document.getElementById('playBtn').disabled = isPlaying || animationQueue.length === 0;
            document.getElementById('pauseBtn').disabled = !isPlaying;
            document.getElementById('stepBtn').disabled = isPlaying || animationQueue.length === 0;
            
            const manualInputs = [
                document.getElementById('keyInput'),
                document.getElementById('deleteInput'),
                document.getElementById('orderSelect'),
            ];
            
            const manualButtons = [
                document.querySelector('button[onclick="insertKey()"]'),
                document.querySelector('button[onclick="deleteKey()"]'),
                document.querySelector('button[onclick="generateInsertSequence()"]'),
                document.querySelector('button[onclick="generateDeleteSequence()"]'),
                document.querySelector('button[onclick="generateRandomTree()"]'),
                document.querySelector('button[onclick="clearTree()"]'),
            ];

            const disableControls = isPlaying || animationQueue.length > 0;
            manualInputs.forEach(input => input.disabled = disableControls);
            manualButtons.forEach(button => button.disabled = disableControls);
        }

        function playAnimation() {
            if (isAnimating) return;
            isAnimating = true;
            setAnimationControls(true);
            processAnimationStep();
        }

        function pauseAnimation() {
            isAnimating = false;
            setAnimationControls(false);
            showNotification('Animation Paused', 'info', 1500);
        }

        function stepForward() {
            if (isAnimating || animationQueue.length === 0) return;
            // Process one step without setting the isAnimating flag to true
            processAnimationStep(true); 
        }

        function processAnimationStep(isManualStep = false) {
            if (animationQueue.length === 0) {
                isAnimating = false;
                setAnimationControls(false);
                document.getElementById('lastOp').textContent = 'Complete';
                showNotification('Operation Complete!', 'success', 2000);
                return;
            }

            if (isAnimating || isManualStep) {
                const step = animationQueue.shift();
                executeAnimationStep(step);
                
                if (isAnimating) {
                    setTimeout(() => {
                        processAnimationStep();
                    }, animationSpeed);
                } else if (animationQueue.length > 0) {
                    setAnimationControls(false); // Re-enable step/play after a manual step
                } else {
                    // Last step in manual mode
                    isAnimating = false;
                    setAnimationControls(false);
                    document.getElementById('lastOp').textContent = 'Complete';
                    showNotification('Operation Complete!', 'success', 2000);
                }
            } else {
                setAnimationControls(false);
            }
        }

        function executeAnimationStep(step) {
            let duration = animationSpeed * 0.8;
            
            // Clear all temporary highlights
            document.querySelectorAll('.node-box').forEach(el => el.classList.remove('highlighted', 'splitting', 'merging'));
            document.querySelectorAll('.node-key').forEach(el => el.classList.remove('new', 'deleting', 'promoting', 'demoting', 'borrowed'));
            document.querySelectorAll('.tree-edge').forEach(el => el.classList.remove('highlighted'));

            switch (step.type) {
                // --- INSERTION STEPS ---
                case 'new_root':
                    renderTree(bTree.root);
                    highlightNode(step.node.id, 'root', duration);
                    addStep('Insert Root', `The tree is empty. Key ${step.key} becomes the first (root) key.`, true);
                    document.getElementById('lastOp').textContent = `Insert ${step.key}`;
                    updatePseudocode([
                        `// Insert ${step.key}`,
                        `KEY = ${step.key}`,
                        `if (ROOT == null)`,
                        `  ROOT = new NODE(${step.key})`,
                        `  RETURN`
                    ]);
                    break;
                case 'traverse_insert':
                    renderTree(bTree.root);
                    highlightNode(step.node.id, 'highlighted', duration);
                    if (!step.node.isLeaf) highlightEdge(step.node.id, step.node.children[step.childIndex].id, 'highlighted', duration);
                    addStep('Traverse Down', `Searching for leaf node to insert ${step.key}. Descending via child pointer ${step.childIndex}.`, true);
                    updatePseudocode([
                        `// Inserting ${step.key}`,
                        `KEY = ${step.key}`,
                        `// 1. Find child pointer C[i] to follow`,
                        `i = NODE.findKeyIndex(KEY)`,
                        `if (NODE.C[i] is full)`,
                        `  CALL splitChild(NODE, i)`,
                        `// Continue search/insert in correct child`
                    ]);
                    break;
                case 'split_child_start':
                    highlightNode(step.child.id, 'splitting', duration);
                    addStep('Node Full: Split Required', `Child node is full (Max ${MAX_KEYS} keys). Preparing to split child node ${step.child.keys.join(',')}.`, true);
                    document.getElementById('lastOp').textContent = `Split on Insert`;
                    updatePseudocode([
                        `// Split required at NODE ${step.child.keys.join(',')}`,
                        `CALL splitChild(PARENT, i)`,
                        `// Split Child(P, i):`,
                        `// 1. Create new sibling NODE`,
                        `// 2. Move median key P.K[i] up to PARENT`,
                        `// 3. Redistribute keys/children between child and new sibling`
                    ]);
                    break;
                case 'split_complete':
                    renderTree(bTree.root);
                    highlightNode(step.parent.id, 'highlighted', duration * 2);
                    highlightKey(step.parent.id, step.promotedKey, 'promoting', duration * 2);
                    addStep('Split Complete', `Key ${step.promotedKey} promoted to parent node. Node split into two: ${step.fullChild.keys.join(',')} and ${step.newNode.keys.join(',')}.`, true);
                    break;
                case 're_traverse':
                    renderTree(bTree.root);
                    highlightNode(step.node.id, 'highlighted', duration);
                    highlightEdge(step.node.id, step.node.children[step.childIndex].id, 'highlighted', duration);
                    addStep('Re-Traverse', `After split, key ${step.key} belongs in the newly created right sibling. Descending right.`, true);
                    break;
                case 'inserted_leaf':
                    renderTree(bTree.root);
                    highlightNode(step.node.id, 'success', duration);
                    highlightKey(step.node.id, step.key, 'new', duration);
                    addStep('Key Inserted', `Key ${step.key} inserted into leaf node at index ${step.index}.`, true);
                    updatePseudocode([
                        `// Key ${step.key} inserted`,
                        `if (NODE is leaf)`,
                        `  NODE.keys.insert(${step.key}, i)`,
                        `  RETURN`
                    ]);
                    break;
                
                // --- DELETION STEPS ---
                case 'found_for_delete':
                    highlightNode(step.node.id, 'warning', duration);
                    document.getElementById('lastOp').textContent = `Delete ${step.key}`;
                    addStep('Found Key', `Found key ${step.key} to be deleted in node ${step.node.keys.join(',')}.`, true);
                    updatePseudocode([
                        `// Delete ${step.key}`,
                        `KEY = ${step.key}`,
                        `// 1. Search for KEY`,
                        `if (NODE.K[i] == KEY)`,
                        `  if (NODE is leaf) // Case 1a`,
                        `    NODE.keys.remove(i)`,
                        `  else // Case 1b`,
                        `    CALL handleInternalDelete(NODE, i)`
                    ]);
                    break;
                case 'deleted_leaf':
                    renderTree(bTree.root); // Rerender to show removal
                    highlightNode(step.node.id, 'danger', duration);
                    addStep('Key Removed (Leaf)', `Key ${step.key} removed from leaf node.`, true);
                    break;
                case 'traverse_delete':
                    renderTree(bTree.root);
                    highlightNode(step.node.id, 'highlighted', duration);
                    highlightEdge(step.node.id, step.node.children[step.childIndex].id, 'highlighted', duration);
                    addStep('Traverse Down', `Searching for key ${step.key} in the subtree. Descending via child pointer ${step.childIndex}.`, true);
                    updatePseudocode([
                        `// 2. If NODE is internal: descend`,
                        `CHILD = NODE.C[i]`,
                        `if (CHILD.keys.length == t-1)`,
                        `  CALL handleDeficientChild(NODE, i)`,
                        `CALL deleteKeyFromNode(CHILD, KEY)`
                    ]);
                    break;
                case 'predecessor_swap':
                    renderTree(bTree.root);
                    highlightKey(step.node.id, step.key, 'deleting', duration);
                    highlightKey(step.node.id, step.predecessor, 'borrowed', duration);
                    addStep('Swap with Predecessor', `Key ${step.key} swapped with its predecessor (${step.predecessor}) from the left child's leaf node.`, true);
                    break;
                case 'successor_swap':
                    renderTree(bTree.root);
                    highlightKey(step.node.id, step.key, 'deleting', duration);
                    highlightKey(step.node.id, step.successor, 'borrowed', duration);
                    addStep('Swap with Successor', `Key ${step.key} swapped with its successor (${step.successor}) from the right child's leaf node.`, true);
                    break;
                case 'merge_children_start':
                    highlightNode(step.leftChild.id, 'merging', duration);
                    highlightNode(step.rightChild.id, 'merging', duration);
                    highlightKey(step.parent.id, step.key, 'demoting', duration);
                    addStep('Internal Merge Required', `Key ${step.key} is internal, but both children are minimal. Key ${step.key} will be pushed down, and children will merge.`, true);
                    break;
                case 'deficient_child':
                    highlightNode(step.child.id, 'danger', duration);
                    addStep('Deficient Child Detected', `Child node ${step.child.keys.join(',')} is deficient (only ${step.child.keys.length} keys). Attempting restructure.`, true);
                    break;
                case 'borrow_left_start':
                    highlightNode(step.child.id, 'highlighted', duration);
                    highlightNode(step.leftSibling.id, 'highlighted', duration);
                    addStep('Borrow from Left', `Left sibling has enough keys (${step.leftSibling.keys.length}). Borrowing largest key, demoting parent key.`, true);
                    break;
                case 'borrow_left_end':
                    renderTree(bTree.root);
                    highlightNode(step.child.id, 'success', duration);
                    highlightKey(step.child.id, step.parentKey, 'demoting', duration);
                    highlightKey(step.parent.id, step.borrowedKey, 'promoting', duration);
                    addStep('Borrow Complete', `Sibling key ${step.borrowedKey} promoted. Parent key ${step.parentKey} demoted. Child is no longer deficient.`, true);
                    break;
                case 'merge_left_start':
                    highlightNode(step.child.id, 'merging', duration);
                    highlightNode(step.leftSibling.id, 'merging', duration);
                    addStep('Merge Left', `Left sibling is minimal. Merging deficient child into left sibling, pulling down parent key.`, true);
                    break;
                case 'merge_right_start':
                    highlightNode(step.child.id, 'merging', duration);
                    highlightNode(step.rightSibling.id, 'merging', duration);
                    addStep('Merge Right', `Right sibling is minimal. Merging deficient child with right sibling, pulling down parent key.`, true);
                    break;
                case 'merged_complete':
                    renderTree(bTree.root);
                    highlightNode(step.left.id, 'success', duration);
                    highlightKey(step.left.id, step.medianKey, 'demoting', duration);
                    addStep('Merge Complete', `Node ${step.right.keys.join(',')} merged into ${step.left.keys.join(',')}. Parent key ${step.medianKey} absorbed.`, true);
                    break;
                case 'root_collapsed':
                    renderTree(bTree.root);
                    highlightNode(step.newRoot.id, 'root', duration);
                    addStep('Root Collapse', `Old root had 0 keys. The tree height reduced. New root is ${step.newRoot.keys.join(',')}.`, true);
                    break;
                case 'tree_cleared':
                    renderTree(null);
                    clearSteps();
                    showNotification('Tree Cleared', 'success', 2000);
                    break;

                // --- SEARCH STEPS ---
                case 'search_traverse':
                    renderTree(bTree.root);
                    highlightNode(step.node.id, 'highlighted', duration);
                    highlightEdge(step.node.id, step.node.children[step.childIndex].id, 'highlighted', duration);
                    addStep('Search Traverse', `Key ${step.key} is between node keys. Descending via child pointer ${step.childIndex}.`, true);
                    break;
                case 'search_hit':
                    renderTree(bTree.root);
                    highlightNode(step.node.id, 'warning', duration * 2);
                    highlightKey(step.node.id, step.key, 'new', duration * 2);
                    addStep('Search Hit!', `Key ${step.key} found in node ${step.node.keys.join(',')} at index ${step.index}.`, true);
                    document.getElementById('lastOp').textContent = `Search ${step.key} (Found)`;
                    break;
                case 'search_miss_leaf':
                    renderTree(bTree.root);
                    highlightNode(step.node.id, 'danger', duration * 2);
                    addStep('Search Miss', `Key ${step.key} not found in this leaf node. Search complete.`, true);
                    document.getElementById('lastOp').textContent = `Search ${step.key} (Miss)`;
                    break;

                default:
                    console.log("Unhandled step:", step);
                    break;
            }
            
            // Re-render and update stats after every change step
            if (step.type.includes('insert') || step.type.includes('delete') || step.type.includes('split') || step.type.includes('merge') || step.type.includes('borrow') || step.type.includes('collapse') || step.type.includes('clear')) {
                // Ensure tree is fully rendered *before* the next step
                // For steps that don't involve structural change (like highlight/traverse), we use the previous render.
                if (!step.type.includes('traverse') && !step.type.includes('search')) {
                    renderTree(bTree.root);
                }
            }

            // If manually stepping, pause after executing
            if (isManualStep) {
                isAnimating = false;
                setAnimationControls(false);
            }
        }


        // --- User Interaction Functions ---

        function changeTreeOrder() {
            if (bTree && bTree.totalKeys > 0) {
                showNotification('Please clear the tree before changing the degree (t).', 'error');
                document.getElementById('orderSelect').value = MIN_DEGREE;
                return;
            }
            const degree = document.getElementById('orderSelect').value;
            MIN_DEGREE = parseInt(degree);
            MAX_KEYS = 2 * MIN_DEGREE - 1;
            MIN_KEYS = MIN_DEGREE - 1;
            
            // Re-init tree instance if it exists
            if (bTree) {
                bTree.init(MIN_DEGREE);
                renderTree(null);
                clearSteps();
                document.getElementById('lastOp').textContent = 'None';
            }
            
            updateDisplayInfo();
            showNotification(`B-Tree degree changed to t=${MIN_DEGREE}.`, 'info');
        }

        function insertKey() {
            const input = document.getElementById('keyInput');
            const key = input.value;
            input.value = ''; // Clear input immediately
            
            if (!key) {
                showNotification('Please enter a key to insert.', 'error');
                return;
            }
            
            if (bTree === null) {
                bTree = new BTree();
                bTree.init(MIN_DEGREE);
            }
            
            const steps = bTree.insert(key);
            if (steps.length > 0) {
                animationQueue = animationQueue.concat(steps);
                playAnimation();
            }
        }

        function deleteKey() {
            const input = document.getElementById('deleteInput');
            const key = input.value;
            input.value = ''; // Clear input immediately
            
            if (!bTree || bTree.totalKeys === 0) {
                showNotification('The tree is empty.', 'error');
                return;
            }
            
            if (!key) {
                showNotification('Please enter a key to delete.', 'error');
                return;
            }
            
            const steps = bTree.delete(key);
            if (steps.length > 0) {
                animationQueue = animationQueue.concat(steps);
                playAnimation();
            }
        }

        function clearTree() {
            if (bTree) {
                bTree.clear();
            } else {
                bTree = new BTree();
                bTree.init(MIN_DEGREE);
            }
            animationQueue = [];
            isAnimating = false;
            renderTree(null);
            clearSteps();
            document.getElementById('lastOp').textContent = 'None';
            setAnimationControls(false);
            showNotification('B-Tree has been reset.', 'success');
        }

        function generateRandomTree() {
            clearTree();
            bTree = new BTree();
            bTree.init(MIN_DEGREE);
            
            const count = Math.floor(Math.random() * (KEY_COUNT_LIMIT - MIN_KEYS)) + MIN_KEYS; // 2 to 50 keys
            const randomKeys = new Set();
            while (randomKeys.size < count) {
                randomKeys.add(Math.floor(Math.random() * 1000));
            }

            Array.from(randomKeys).sort((a, b) => a - b).forEach(key => {
                const steps = bTree.insert(key);
                animationQueue = animationQueue.concat(steps);
            });
            
            document.getElementById('lastOp').textContent = `Auto-Insert (${count} keys)`;
            showNotification(`Auto-inserting ${count} random keys...`, 'info');
            playAnimation();
        }

        function generateInsertSequence() {
            clearTree();
            bTree = new BTree();
            bTree.init(MIN_DEGREE);
            
            const keys = [10, 20, 30, 40, 50, 60, 70, 80, 5, 25, 45, 65, 85, 35, 75];
            keys.forEach(key => {
                const steps = bTree.insert(key);
                animationQueue = animationQueue.concat(steps);
            });
            
            document.getElementById('lastOp').textContent = `Auto-Insert Sequence`;
            showNotification('Auto-inserting a defined sequence...', 'info');
            playAnimation();
        }

        function generateDeleteSequence() {
            if (!bTree || bTree.totalKeys === 0) {
                showNotification('Please insert keys first to generate a deletion sequence.', 'error');
                return;
            }
            
            const keysToDelete = [...bTree.nodes[bTree.root.id].keys]; // Start with current root keys
            
            // Get all keys from the tree (in-order traversal)
            const allKeys = [];
            function inOrder(node) {
                if (!node) return;
                for (let i = 0; i < node.keys.length; i++) {
                    if (node.children[i]) inOrder(node.children[i]);
                    allKeys.push(node.keys[i]);
                }
                if (node.children[node.keys.length]) inOrder(node.children[node.keys.length]);
            }
            inOrder(bTree.root);
            
            // Randomly select half the keys to delete
            const keysToSelect = Math.min(Math.ceil(allKeys.length / 2), 15);
            const deleteSet = new Set();
            while(deleteSet.size < keysToSelect && allKeys.length > 0) {
                const randomIndex = Math.floor(Math.random() * allKeys.length);
                deleteSet.add(allKeys.splice(randomIndex, 1)[0]);
            }
            
            Array.from(deleteSet).forEach(key => {
                const steps = bTree.delete(key);
                animationQueue = animationQueue.concat(steps);
            });
            
            document.getElementById('lastOp').textContent = `Auto-Delete Sequence`;
            showNotification(`Auto-deleting ${deleteSet.size} random keys...`, 'info');
            playAnimation();
        }
        
        // --- Zoom Functions ---

        function updateZoom(factor) {
            currentZoom = Math.min(Math.max(0.5, currentZoom * factor), 2.0); // Limit zoom range
            document.getElementById('treeNodesContainer').style.transform = `scale(${currentZoom})`;
        }

        function zoomIn() {
            updateZoom(1.1);
        }

        function zoomOut() {
            updateZoom(0.9);
        }

        function resetZoom() {
            currentZoom = 1.0;
            document.getElementById('treeNodesContainer').style.transform = `scale(${currentZoom})`;
        }
        
        // --- Theme Toggle ---
        
        function toggleTheme() {
            const root = document.documentElement;
            const isDark = root.style.getPropertyValue('--dark-mode') === 'true';
            
            if (isDark) {
                root.style.removeProperty('--dark-mode');
                // Set light mode styles
                document.body.style.background = 'linear-gradient(135deg, #667eea 0%, #764ba2 100%)';
            } else {
                root.style.setProperty('--dark-mode', 'true');
                // Set dark mode styles
                root.style.setProperty('--primary', '#818cf8');
                root.style.setProperty('--primary-dark', '#6366f1');
                root.style.setProperty('--secondary', '#a78bfa');
                root.style.setProperty('--success', '#34d399');
                root.style.setProperty('--warning', '#fbbf24');
                root.style.setProperty('--danger', '#f87171');
                root.style.setProperty('--dark', '#f8fafc');
                root.style.setProperty('--light', '#1f2937');
                root.style.setProperty('--border', '#374151');
                document.body.style.background = 'linear-gradient(135deg, #1f2937 0%, #111827 100%)';
                document.querySelectorAll('.panel').forEach(p => p.style.backgroundColor = '#1f2937');
                document.querySelectorAll('.panel-header').forEach(p => p.style.borderBottomColor = '#374151');
                document.querySelectorAll('.stat-card').forEach(p => p.style.background = 'linear-gradient(135deg, #1f2937 0%, #374151 100%)');
                document.querySelectorAll('.panel-title').forEach(p => p.style.color = '#f8fafc');
                document.querySelectorAll('.form-label').forEach(p => p.style.color = '#f8fafc');
            }
        }


        // --- Initialization ---

        window.onload = () => {
            bTree = new BTree();
            bTree.init(MIN_DEGREE);
            updateSpeedDisplay(document.getElementById('speedSlider').value);
            document.getElementById('speedSlider').oninput = (e) => updateSpeedDisplay(e.target.value);
        };
    </script>
</body>
</html>
